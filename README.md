# EasyTcpServer
TCP服务器和客户端

1.0:使用recv send等函数进行单次收发

1.1:服务器和客户端通过while循环，一对一交互

1.2:将发送的报文进行结构化和封装，可以通过一次收发对信息进行处理

1.3：使用select模型升级服务器和客户端，使得服务器可以处理多个客户端的连接，timeval参数设置后成为非阻塞select，增加处理其他事务的能力

1.4：使用thread修改客户端，分离出一个线程用来输入命令。增加Linux版本客户端

1.5: 对客户端和服务器进行类封装 处理客户端和服务器的粘包少包问题 用标准库chrono提供的计时器来计算服务端接收速度
在socket网络模型下 连接较多时处理的延迟较高 会达到毫秒微秒 且新连接加入变慢

1.6:使用多线程分离出连接接收和消息处理线程，一个接收连接线程和几个消息接收线程之间通过一个缓冲队列来传递加入的客户端（生产者-消费者模式）

1.7：通过加入一个接口来让消息接收线程通知客户端的退出事件，并删除接收连接和接受消息函数多余的部分

目前在本地测试下，对于一万个连接，接入时间大概在十秒内，每个连接一次进行10个字节的发送，能够达到每秒六十万包的收发速度

1.7.1 对每一次有修改的描述符集合进行备份，避免在描述符未发生变化时依旧重新添加进集合浪费性能。
使用map来存储socket和客户端的映射,避免每次调用FD_ISSET来检查描述符是否被设置。
目前的性能瓶颈为select对描述符的轮询及send和recv

1.8 使用内存池对内存分配进行管理，因为本项目中每收到一个消息都会new一个对象回复，使用内存池可以减少频繁分配内存的消耗。将使用new创建普通指针的地方都更换成智能指针，虽然会少量降低性能，但能降低内存泄漏的可能。使用对象池管理经常会接入和离开的客户端对象，降低每次有用户连接进来时需要创建新对象的消耗。

1.9 增加心跳检测功能:在命令头中增加心跳包结构，通过是否接收到心跳信息来检测客户端是否存活并删除已经死亡的客户端。通过定时发送功能，经过一段时间未发送数据时发送缓冲区。使用信号量来控制不同线程的先后释放顺序，信号量由条件变量实现。将线程的控制封装成一个类，更好的管理线程的创建，运行及销毁。

1.9.1 将同步阻塞发送更改为异步发送，即先将发送数据写入缓冲区，等待可写描述符为什么选择异步发送：同步发送需要双发建立同步且需要连接环境较稳定，一旦接入的客户端有某个出现问题，就会影响整个服务器对所有客户端的收发过程
